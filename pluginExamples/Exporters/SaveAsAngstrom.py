import os
import logging
import datetime

from EnlightenPlugin import EnlightenPluginBase,    \
                            EnlightenPluginField,    \
                            EnlightenPluginResponse,  \
                            EnlightenPluginConfiguration

log = logging.getLogger(__name__)

##
# This writes received spectra into a custom folder with a different
# file format than ENLIGHTEN.
class SaveAsAngstrom(EnlightenPluginBase):

    def __init__(self, ctl):
        super().__init__(ctl)

        # e.g. C:\Users\mzieg\Documents\EnlightenSpectra\SaveAsAngstrom
        self.directory = os.path.join(self.ctl.save_options.get_directory(), "SaveAsAngstrom")
        self.basename = "angstrom"
        self.count = 0

    ##
    # There are two interesting things here:
    #
    # 1. We disable streaming, as we don't want to save every new reading to disk
    #    (only when the user actually hits the "Save" button).  
    # 2. We're registering an observer on ENLIGHTEN's "save" event, so every time
    #    MeasurementFactory creates a new Measurement from a connected spectro-
    #    meter, it will send a copy of the Measurement our way.
    def get_configuration(self):
        return EnlightenPluginConfiguration(
            name        = "Save As Å/cm⁻¹", 
            events      = { "save": self.save_measurement }, 
            streaming   = False,               
            is_blocking = False)

    ## @returns False if it can't create / find the target directory
    def connect(self, enlighten_info):
        super().connect(enlighten_info)
        return self.ensure_exists(self.directory)

    ##
    # This is the default process_request method that all ENLIGHTEN plug-ins have.
    # It receives EnlightenPluginRequests, as normal.
    def process_request(self, request):

        # use our private save method, passing in parts of the request
        self.save(request.processed_reading, request.settings)

        # return a simple response to avoid flowing a poison-pill upstream
        return EnlightenPluginResponse(request)

    def disconnect(self):
        super().disconnect()

    # ##########################################################################
    # private methods
    # ##########################################################################

    ##
    # This callback receives new enlighten.Measurement objects generated by 
    # MeasurementFactory. They have more stuff than EnlightenPluginRequests, so 
    # just pull out the bits we want.
    def save_measurement(self, measurement):
        self.save(measurement.processed_reading, measurement.spec.settings)

    def save(self, pr, settings):
        timestamp = datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
        filename = f"{self.basename}-{timestamp}-{self.count}.csv"
        pathname = os.path.join(self.directory, filename)

        log.info(f"saving {pathname}")
        with open(pathname, 'w', encoding="utf-8") as f:
            f.write('pixel, angstrom (Å), absolute wavenumber (cm⁻¹), intensity\n')
            for i in range(len(pr.processed)):
                nm = settings.wavelengths[i]
                angstrom = 10.0 * nm
                absolute_wavenumber = 1.0 / (nm / 1e7) # NOT Raman shift!
                f.write("%04d, %.5e, %.2f, %.3f\n" % (i, angstrom, absolute_wavenumber, pr.processed[i]))

        self.count += 1

    def ensure_exists(self, directory):
        if not os.path.exists(directory):
            os.makedirs(directory)
        return os.path.exists(directory)
